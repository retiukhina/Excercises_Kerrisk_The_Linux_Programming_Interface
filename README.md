## WHAT SIGNAL IS

A signal is a notification that some kind of event has occurred, and may be sent to a
process by the kernel, by another process, or by itself.

Signal delivery is typically asynchronous, meaning that the point at which the
signal interrupts execution of the process is unpredictable. In some cases (e.g.,
hardware-generated signals), signals are delivered synchronously, meaning that
delivery occurs predictably and reproducibly at a certain point in the execution of a
program.

One process can (if it has suitable permissions) send a signal to another process.
In this use, signals can be employed as a synchronization technique, or even as a
primitive form of interprocess communication (IPC). It is also possible for a pro-
cess to send a signal to itself. However, the usual source of many signals sent to a
process is the kernel. Among the types of events that cause the kernel to generate a
signal for a process are the following:

1. A hardware exception occurred, meaning that the hardware detected a fault
condition that was notified to the kernel, which in turn sent a corresponding
signal to the process concerned. Examples of hardware exceptions include
executing a malformed machine-language instruction, dividing by 0, or referencing a part 
of memory that is inaccessible.
2. The user typed one of the terminal special characters that generate signals.
These characters include the interrupt character (usually Control-C) and the
suspend character (usually Control-Z).
3. A software event occurred. For example, input became available on a file
descriptor, the terminal window was resized, a timer went off, the process’s
CPU time limit was exceeded, or a child of this process terminated.

Each signal is defined as a unique (small) integer, starting sequentially from 1.
These integers are defined in <signal.h> with symbolic names of the form SIGxxxx.
Since the actual numbers used for each signal vary across implementations, it is
these symbolic names that are always used in programs.

Signals fall into two broad categories. The first set constitutes the traditional or
standard signals (Linux signal(7) manual page), which are used by the kernel to notify processes of events. On
Linux, the standard signals are numbered from 1 to 31. The other set of signals consists 
of the realtime signals.

A signal is said to be generated by some event. Once generated, a signal is later
delivered to a process, which then takes some action in response to the signal.
Between the time it is generated and the time it is delivered, a signal is said to be
pending.

Normally, a pending signal is delivered to a process as soon as it is next sched-
uled to run, or immediately if the process is already running (e.g., if the process
sent a signal to itself). Sometimes, however, we need to ensure that a segment of
code is not interrupted by the delivery of a signal. To do this, we can add a signal to
the process’s signal mask — a set of signals whose delivery is currently blocked. They are stored 
then in the process's pending signal set inside the kernel. If a signal
is generated while it is blocked, it remains pending until it is later unblocked
(removed from the signal mask).

Upon delivery of a signal, a process carries out one of the following default
actions, depending on the signal:
- The signal is ignored; that is, it is discarded by the kernel and has no effect on
the process. (The process never even knows that it occurred.)
- The process is terminated (killed). This is sometimes referred to as abnormal
process termination, as opposed to the normal process termination that occurs
when a process terminates using exit().
- A core dump file is generated, and the process is terminated. A core dump file
contains an image of the virtual memory of the process, which can be loaded
into a debugger in order to inspect the state of the process at the time that it
terminated. 
- The process is stopped—execution of the process is suspended.
- Execution of the process is resumed after previously being stopped.

## DISPOSITION OF A SIGNAL:

Disposition of a signal is an establishing of the action which should occure when the signal is delivered.
A program can set one of the following dispositions for a signal:

- The default action should occur. This is useful to undo an earlier change of the
disposition of the signal to something other than its default.
- The signal is ignored. This is useful for a signal whose default action would be to
terminate the process.
- A signal handler is executed.

A signal handler is a function, written by the programmer, that performs appropri-
ate tasks in response to the delivery of a signal. For example, the shell has a handler
for the SIGINT signal (generated by the interrupt character, Control-C) that causes it to
stop what it is currently doing and return control to the main input loop, so that
the user is once more presented with the shell prompt.

Note that it isn’t possible to set the disposition of a signal to terminate or dump
core (unless one of these is the default disposition of the signal). This means that you cannot manually 
force a signal to have a termination or core-dumping behavior using sigaction() or signal().
The nearest we can get to this is to install a handler for the signal that then calls either exit() or abort().
The abort() function (Section 21.2.2) generates a SIGABRT signal for the process,
which causes it to dump core and terminate.

## CHANGING SIGNAL DISPOSITION: signal() vs sigaction()

UNIX systems provide two ways of changing the disposition of a signal: signal() and
sigaction(). The signal() system call, which is described in this section, was the origi-
nal API for setting the disposition of a signal, and it provides a simpler interface
than sigaction(). On the other hand, sigaction() provides functionality that is not
available with signal(). Furthermore, there are variations in the behavior of signal()
across UNIX implementations (Section 22.7), which mean that it should never be
used for establishing signal handlers in portable programs. Because of these porta-
bility issues, sigaction() is the (strongly) preferred API for establishing a signal handler.

## SIGNAL HANDLERS

A signal handler (also called a signal catcher) is a function that is called when a speci-
fied signal is delivered to a process. Invocation of a signal handler may interrupt the main 
program flow at any time; the kernel calls the handler on the process’s behalf, and when the handler
returns, execution of the program resumes at the point where the handler inter-
rupted it.

When the kernel invokes a signal handler, it passes the number of the signal that
caused the invocation as an integer argument to the handler. (This is the sig argu-
ment in the handler). If a signal handler catches only one type of signal,
then this argument is of little use. We can, however, establish the same handler to
catch different types of signals and use this argument to determine which signal
caused the handler to be invoked.

! Real-world applications should generally never call stdio functions from within a signal handler.

## SENDING SIGNALS: kill()

One process can send a signal to another process using the kill() system call, which
is the analog of the kill shell command.

The pid argument identifies one or more processes to which the signal specified by
sig is to be sent. Four different cases determine how pid is interpreted:

1. If pid is greater than 0, the signal is sent to the process with the process ID spec-
ified by pid.
2. If pid equals 0, the signal is sent to every process in the same process group as
the calling process, including the calling process itself. (SUSv3 states that the
signal should be sent to all processes in the same process group, excluding an
“unspecified set of system processes” and adds the same qualification to each
of the remaining cases.)
3. If pid is less than –1, the signal is sent to all of the processes in the process group
whose ID equals the absolute value of pid. Sending a signal to all of the processes
in a process group finds particular use in shell job control (Section 34.7).
4. If pid equals –1, the signal is sent to every process for which the calling process
has permission to send a signal, except init (process ID 1) and the calling pro-
cess. If a privileged process makes this call, then all processes on the system will
be signaled, except for these last two. For obvious reasons, signals sent in this
way are sometimes called broadcast signals. (SUSv3 doesn’t require that the call-
ing process be excluded from receiving the signal; Linux follows the BSD
semantics in this regard.)
5. If no process matches the specified pid, kill() fails and sets errno to ESRCH (“No such
process”).

A process needs appropriate permissions to be able send a signal to another process.

## SIGNAL SETS

Multiple signals are represented using a data structure called a signal set, provided by the system data type 
sigset_t.

The sigemptyset() function initializes a signal set to contain no members. The
sigfillset() function initializes a set to contain all signals (including all realtime signals).

One of sigemptyset() or sigaddset() must be used to initialize a signal set. This is
because C doesn’t initialize automatic (local) variables, and the initialization of static variables to 0 can’t 
portably be relied upon as indicating an empty signal set, since signal sets may be implemented using structures 
other than bit masks (bit masks is an array of bits). (For the same reason, it is incorrect to use memset(3) 
to zero the contents of a signal set in order to mark it as empty,  because it assumes that the memory structure of the signal set is a simple block of memory 
(which can be zeroed out).)

After initialization, individual signals can be added to a set using sigaddset() and
removed using sigdelset(). 
The sigismember() function is used to test for membership of a set.
The sigismember() function returns 1 (true) if sig is a member of set, and 0 (false)
otherwise.

## THE SIGNAL MASK (Blocking Signal Delivery)

For each process, the kernel maintains a signal mask—a set of signals whose delivery
to the process is currently blocked. If a signal that is blocked is sent to a process,
delivery of that signal is delayed until it is unblocked by being removed from the
process signal mask.

A signal may be added to the signal mask in the following ways:
When a signal handler is invoked, the signal that caused its invocation can be
automatically added to the signal mask. Whether or not this occurs depends on
the flags used when the handler is established using sigaction().
- When a signal handler is established with sigaction(), it is possible to specify an
additional set of signals that are to be blocked when the handler is invoked.
- The sigprocmask() system call can be used at any time to explicitly add signals to,
and remove signals from, the signal mask.

We can use sigprocmask() to change the process signal mask, to retrieve the existing
mask, or both.

## PENDING SIGNALS

If a process receives a signal that it is currently blocking, that signal is added to the
process’s set of pending signals. When (and if) the signal is later unblocked, it is
then delivered to the process. To determine which signals are pending for a pro-
cess, we can call sigpending().

The sigpending() system call returns the set of signals that are pending for the call-
ing process in the sigset_t structure pointed to by set. We can then examine set using
the sigismember() function.

If we change the disposition of a pending signal, then, when the signal is later
unblocked, it is handled according to its new disposition. Although not often used,
one application of this technique is to prevent the delivery of a pending signal by
setting its disposition to SIG_IGN, or to SIG_DFL if the default action for the signal is
ignore. As a result, the signal is removed from the process’s set of pending signals
and thus not delivered.

## sigaction()

In particular, sigaction() allows us to retrieve
the disposition of a signal without changing it, and to set various attributes control-
ling precisely what happens when a signal handler is invoked. Additionally, as we’ll
elaborate in Section 22.7, sigaction() is more portable than signal() when establish-
ing a signal handler.

The sig argument identifies the signal whose disposition we want to retrieve or
change. This argument can be any signal except SIGKILL or SIGSTOP. The act argument 
is a pointer to a structure specifying a new disposition for the signal. If we are interested 
only in finding the existing disposition of the signal, then we can specify NULL for this argument. 
The oldact argument is a pointer to a structure of the same type, and is used to return information 
about the signal’s previous disposition. If we are not interested in this information, then we can specify
NULL for this argument.

The structures pointed to by act and oldact are of the following type:
struct sigaction
{
    void        (*sa_handler)(int); /* Address of handler */
    sigset_t    sa_mask; /* Signals blocked during handler invocation */
    int         sa_flags;  /* Flags controlling handler invocation */
    void       (*sa_restorer)(void); /* Not for application use */
};

The sigaction structure is actually somewhat more complex than shown here.

The sa_handler field corresponds to the handler argument given to signal(). It speci-
fies the address of a signal handler, or one of the constants SIG_IGN or SIG_DFL. The
sa_mask and sa_flags fields, which we discuss in a moment, are interpreted only if
sa_handler is the address of a signal handler—that is, a value other than SIG_IGN or
SIG_DFL.

The sa_mask field defines a set of signals that are to be blocked during invocation of
the handler defined by sa_handler. When the signal handler is invoked, any signals in
this set that are not currently part of the process signal mask are automatically
added to the mask before the handler is called. These signals remain in the process
signal mask until the signal handler returns, at which time they are automatically
removed. The sa_mask field allows us to specify a set of signals that aren’t permitted
to interrupt execution of this handler. In addition, the signal that caused the han-
dler to be invoked is automatically added to the process signal mask. This means
that a signal handler won’t recursively interrupt itself if a second instance of the
same signal arrives while the handler is executing.
